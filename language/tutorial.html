<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Tutorial</title>

    <link rel="stylesheet" type="text/css" href="./formatting.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <nav class="sidebar">
  <p class="location">
      <a href="./index.html">dynasm-rs</a>
  </p>
  <div class = "block modules">
  <h3>Components</h3>
    <ul>
      <li>
        <a href="../language/index.html">Syntax</a>
      </li>
      <li>
        <a href="../plugin/dynasm/index.html">Plugin (dynasm)</a>
      </li>
      <li>
        <a href="../runtime/dynasmrt/index.html">Runtime (dynasmrt)</a>
      </li>
    </ul>
  </div>
  <div class = "block crate">
  <h3>Syntax</h3>
    <ul>
      <li>
        <a href="./index.html">Home</a>
      </li>
      <li>
        <a href="./tutorial.html">Tutorial</a>
      </li>
      <li>
        <a href="./langref.html">Language reference</a>
      </li>
      <li>
        <a href="./instructionref.html">Instruction reference</a>
      </li>
    </ul>
  </div>
</nav>
<section id="main" class="content mod docblock">

    <h1 class="title">Tutorial</h1>
    
<h1 id='introduction' class='section-header'><a href='#introduction'>Introduction</a></h1>
<p>Dynasm-rs is a library and sytnax extension for assembling code at runtime. For the first part of the tutorial we will be examining the following example program that assembles a simple function at runtime:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>plugin</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>plugin</span>(<span class='ident'>dynasm</span>)]</span>

<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>dynasmrt</span>;

<span class='kw'>use</span> <span class='ident'>dynasmrt</span>::<span class='ident'>DynasmApi</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::{<span class='ident'>io</span>, <span class='ident'>slice</span>, <span class='ident'>mem</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Write</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>ops</span> <span class='op'>=</span> <span class='ident'>dynasmrt</span>::<span class='ident'>Assembler</span>::<span class='ident'>new</span>();
    <span class='kw'>let</span> <span class='ident'>string</span> <span class='op'>=</span> <span class='string'>&quot;Hello World!&quot;</span>;

    <span class='macro'>dynasm</span><span class='macro'>!</span>(<span class='ident'>ops</span>
        ; <span class='op'>-&gt;</span><span class='ident'>hello</span>:
        ; .<span class='ident'>bytes</span> <span class='ident'>string</span>.<span class='ident'>as_bytes</span>()
    );

    <span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='ident'>ops</span>.<span class='ident'>offset</span>();
    <span class='macro'>dynasm</span><span class='macro'>!</span>(<span class='ident'>ops</span>
        ; <span class='ident'>lea</span> <span class='ident'>rcx</span>, [<span class='op'>-&gt;</span><span class='ident'>hello</span>]
        ; <span class='ident'>xor</span> <span class='ident'>edx</span>, <span class='ident'>edx</span>
        ; <span class='ident'>mov</span> <span class='ident'>dl</span>, <span class='ident'>BYTE</span> <span class='ident'>string</span>.<span class='ident'>len</span>() <span class='kw'>as</span> _
        ; <span class='ident'>mov</span> <span class='ident'>rax</span>, <span class='ident'>QWORD</span> <span class='ident'>print</span> <span class='kw'>as</span> _
        ; <span class='ident'>sub</span> <span class='ident'>rsp</span>, <span class='ident'>BYTE</span> <span class='number'>0x28</span>
        ; <span class='ident'>call</span> <span class='ident'>rax</span>
        ; <span class='ident'>add</span> <span class='ident'>rsp</span>, <span class='ident'>BYTE</span> <span class='number'>0x28</span>
        ; <span class='ident'>ret</span>
    );

    <span class='kw'>let</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='ident'>ops</span>.<span class='ident'>finalize</span>().<span class='ident'>unwrap</span>();

    <span class='kw'>let</span> <span class='ident'>hello_fn</span>: <span class='kw'>extern</span> <span class='string'>&quot;win64&quot;</span> <span class='kw'>fn</span>() <span class='op'>-&gt;</span> <span class='ident'>bool</span> <span class='op'>=</span> <span class='kw'>unsafe</span> {
        <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>buf</span>.<span class='ident'>ptr</span>(<span class='ident'>hello</span>))
    };

    <span class='macro'>assert</span><span class='macro'>!</span>(
        <span class='ident'>hello_fn</span>()
    );
}

<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='string'>&quot;win64&quot;</span> <span class='kw'>fn</span> <span class='ident'>print</span>(<span class='ident'>buffer</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>, <span class='ident'>length</span>: <span class='ident'>u64</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='ident'>io</span>::<span class='ident'>stdout</span>().<span class='ident'>write_all</span>(<span class='kw'>unsafe</span> {
        <span class='ident'>slice</span>::<span class='ident'>from_raw_parts</span>(<span class='ident'>buffer</span>, <span class='ident'>length</span> <span class='kw'>as</span> <span class='ident'>usize</span>)
    }).<span class='ident'>is_ok</span>()
}</pre>

<p>We will now examine this code snippet piece by piece.</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>plugin</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>plugin</span>(<span class='ident'>dynasm</span>)]</span></pre>

<p>To use the <code>dynasm!</code> procedural macro, first the dynasm plugin has to be loaded. As plugins are currently unstable, the plugin feature first needs to be enabled. This currently requires a nightly version of rustc.</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>dynasmrt</span>;

<span class='kw'>use</span> <span class='ident'>dynasmrt</span>::<span class='ident'>DynasmApi</span>;</pre>

<p>We then link to the dynasm runtime crate. Although they are not used here, it also contains various utility macros which we load here.
Furthermore, the <code>DynasmApi</code> trait is loaded. This trait defines the interface used by the <code>dynasm!</code> procedural macro to produce assembled code.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>ops</span> <span class='op'>=</span> <span class='ident'>dynasmrt</span>::<span class='ident'>Assembler</span>::<span class='ident'>new</span>();</pre>

<p>Of course, the machine code that will be generated will need to live somewhere. <code>dynasmrt::Assembler</code> is a struct that implements the <code>DynasmApi</code> trait, provides storage for the generated machine code, handles memory permissions and provides various utilities for dynamically assembling code. It even allows assembling code in one thread while several other threads execute said code. For this example though, we will use it in the most simple usecase, just assembling everything in advance and then executing it.</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>dynasm</span><span class='macro'>!</span>(<span class='ident'>ops</span>
    ; <span class='op'>-&gt;</span><span class='ident'>hello</span>:
    ; .<span class='ident'>bytes</span> <span class='ident'>string</span>.<span class='ident'>as_bytes</span>()
);</pre>

<p>The first invocation of the <code>dynasm!</code> macro shows of two features of dynasm. The first line defines a global label <code>hello</code> which later can be referenced, while the second line contains an assembler directive. Assembler directives allow the assembler to perform tasks that do not involve instruction assembling like, in this case, inserting a string into the executable buffer.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='ident'>ops</span>.<span class='ident'>offset</span>();</pre>

<p>This utility function returns a value indicating the position of the current end of the machine code buffer. It can later be used to obtain a pointer to this position in the generated machine code.</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>dynasm</span><span class='macro'>!</span>(<span class='ident'>ops</span>
    ; <span class='ident'>lea</span> <span class='ident'>rcx</span>, [<span class='op'>-&gt;</span><span class='ident'>hello</span>]
    ; <span class='ident'>xor</span> <span class='ident'>edx</span>, <span class='ident'>edx</span>
    ; <span class='ident'>mov</span> <span class='ident'>dl</span>, <span class='ident'>BYTE</span> <span class='ident'>string</span>.<span class='ident'>len</span>() <span class='kw'>as</span> _
    ; <span class='ident'>mov</span> <span class='ident'>rax</span>, <span class='ident'>QWORD</span> <span class='ident'>print</span> <span class='kw'>as</span> _
    ; <span class='ident'>sub</span> <span class='ident'>rsp</span>, <span class='ident'>BYTE</span> <span class='number'>0x28</span>
    ; <span class='ident'>call</span> <span class='ident'>rax</span>
    ; <span class='ident'>add</span> <span class='ident'>rsp</span>, <span class='ident'>BYTE</span> <span class='number'>0x28</span>
    ; <span class='ident'>ret</span>
);</pre>

<p>The second invocation of the <code>dynasm!</code> macro contains the definition of a small function. It performs the following tasks:</p>

<pre class='rust rust-example-rendered'>
; <span class='ident'>lea</span> <span class='ident'>rcx</span>, [<span class='op'>-&gt;</span><span class='ident'>hello</span>]</pre>

<p>First, the address of the global label <code>-&gt;hello</code> is loaded using the load effective address instruction and a label memory reference.</p>

<pre class='rust rust-example-rendered'>
; <span class='ident'>xor</span> <span class='ident'>edx</span>, <span class='ident'>edx</span>
; <span class='ident'>mov</span> <span class='ident'>dl</span>, <span class='ident'>BYTE</span> <span class='ident'>string</span>.<span class='ident'>len</span>() <span class='kw'>as</span> _</pre>

<p>Then the length of the string is loaded. Here the <code>BYTE</code> prefix determines the size of the immediate in the second instruction. the <code>as _</code> cast is necessary to coerce the size of the length down to the <code>i8</code> type expected of an immediate. Dynasm-rs tries to avoid performing implicit casts as this tends to hide errors.</p>

<pre class='rust rust-example-rendered'>
; <span class='ident'>mov</span> <span class='ident'>rax</span>, <span class='ident'>QWORD</span> <span class='ident'>print</span> <span class='kw'>as</span> _
; <span class='ident'>sub</span> <span class='ident'>rsp</span>, <span class='ident'>BYTE</span> <span class='number'>0x28</span>
; <span class='ident'>call</span> <span class='ident'>rax</span>
; <span class='ident'>add</span> <span class='ident'>rsp</span>, <span class='ident'>BYTE</span> <span class='number'>0x28</span></pre>

<p>Here, a call is made from the dynamically assembled code to the rust <code>print</code> function. Note the <code>QWORD</code> size prefix which is necessary to determine the appropriate form of the <code>mov</code> instruction to encode as <code>dynasm!</code> does not analyze the immediate expression at runtime. As this example uses the <code>&quot;win64&quot;</code> calling convention, the stack pointer needs to be manipulated too. (Note: the <code>&quot;win64&quot;</code> calling convention is used as this it is currently impossible to use the <code>&quot;sysv64&quot;</code> calling convention on all platforms)</p>

<pre class='rust rust-example-rendered'>
; <span class='ident'>ret</span></pre>

<p>And finally the assembled function returns, returning the return value from the <code>print</code> function in <code>rax</code> back to the caller rust code.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='ident'>ops</span>.<span class='ident'>finalize</span>().<span class='ident'>unwrap</span>();</pre>

<p>With the assembly completed, we now finalize the <code>dynasmrt::Assembler</code>, which will resolve all labels previously used and move the data into a <code>dynasmrt::ExecutableBuffer</code>. This struct, which dereferences to a <code>&amp;[u8]</code>, wraps a buffer of readable and executable memory.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>hello_fn</span>: <span class='kw'>extern</span> <span class='string'>&quot;win64&quot;</span> <span class='kw'>fn</span>() <span class='op'>-&gt;</span> <span class='ident'>bool</span> <span class='op'>=</span> <span class='kw'>unsafe</span> {
    <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>buf</span>.<span class='ident'>ptr</span>(<span class='ident'>hello</span>))
};</pre>

<p>We can now get a pointer to the executable memory using the <code>dynasmrt::ExecutableBuffer::ptr</code> method, using the value obtained earlier from <code>ops.offset()</code>. We can then transmute this pointer into a function.</p>

<pre class='rust rust-example-rendered'>
<span class='macro'>assert</span><span class='macro'>!</span>(
    <span class='ident'>hello_fn</span>()
);</pre>

<p>And finally we can call this function, asserting that it returns true to ensure that it managed to print the encoded message!</p>

<p>And for the people interested in the behind-the-scenes, here&#39;s what the <code>dynasm!</code> macros expand to:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>plugin</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>plugin</span>(<span class='ident'>dynasm</span>)]</span>

<span class='attribute'>#[<span class='ident'>macro_use</span>]</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>dynasmrt</span>;

<span class='kw'>use</span> <span class='ident'>dynasmrt</span>::<span class='ident'>DynasmApi</span>;

<span class='kw'>use</span> <span class='ident'>std</span>::{<span class='ident'>io</span>, <span class='ident'>slice</span>, <span class='ident'>mem</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>io</span>::<span class='ident'>Write</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>ops</span> <span class='op'>=</span> <span class='ident'>dynasmrt</span>::<span class='ident'>Assembler</span>::<span class='ident'>new</span>();
    <span class='kw'>let</span> <span class='ident'>string</span> <span class='op'>=</span> <span class='string'>&quot;Hello World!&quot;</span>;

<span class='comment'>// dynasm!(</span>
    <span class='ident'>ops</span>.<span class='ident'>global_label</span>(<span class='string'>&quot;hello&quot;</span>);
    <span class='ident'>ops</span>.<span class='ident'>extend</span>(<span class='ident'>string</span>.<span class='ident'>as_bytes</span>());
<span class='comment'>// )</span>

    <span class='kw'>let</span> <span class='ident'>hello</span> <span class='op'>=</span> <span class='ident'>ops</span>.<span class='ident'>offset</span>();
<span class='comment'>// dynasm!(</span>
    <span class='ident'>ops</span>.<span class='ident'>extend</span>(<span class='string'>b&quot;H\x8d\r\x00\x00\x00\x00&quot;</span>);
    <span class='ident'>ops</span>.<span class='ident'>global_reloc</span>(<span class='string'>&quot;hello&quot;</span>, <span class='number'>4u8</span>);
    <span class='ident'>ops</span>.<span class='ident'>extend</span>(<span class='string'>b&quot;1\xd2\xb2&quot;</span>);
    <span class='ident'>ops</span>.<span class='ident'>push_8</span>(<span class='ident'>string</span>.<span class='ident'>len</span>() <span class='kw'>as</span> _);
    <span class='ident'>ops</span>.<span class='ident'>extend</span>(<span class='string'>b&quot;H\xb8&quot;</span>);
    <span class='ident'>ops</span>.<span class='ident'>push_64</span>(<span class='ident'>print</span> <span class='kw'>as</span> _);
    <span class='ident'>ops</span>.<span class='ident'>extend</span>(<span class='string'>b&quot;H\x83\xec&quot;</span>);
    <span class='ident'>ops</span>.<span class='ident'>push_8</span>(<span class='number'>40</span>);
    <span class='ident'>ops</span>.<span class='ident'>extend</span>(<span class='string'>b&quot;\xff\xd0H\x83\xc4&quot;</span>);
    <span class='ident'>ops</span>.<span class='ident'>push_8</span>(<span class='number'>40</span>);
    <span class='ident'>ops</span>.<span class='ident'>push</span>(<span class='string'>b&#39;\xc3&#39;</span>);
<span class='comment'>// )</span>

    <span class='kw'>let</span> <span class='ident'>buf</span> <span class='op'>=</span> <span class='ident'>ops</span>.<span class='ident'>finalize</span>().<span class='ident'>unwrap</span>();

    <span class='kw'>let</span> <span class='ident'>hello_fn</span>: <span class='kw'>extern</span> <span class='string'>&quot;win64&quot;</span> <span class='kw'>fn</span>() <span class='op'>-&gt;</span> <span class='ident'>bool</span> <span class='op'>=</span> <span class='kw'>unsafe</span> {
        <span class='ident'>mem</span>::<span class='ident'>transmute</span>(<span class='ident'>buf</span>.<span class='ident'>ptr</span>(<span class='ident'>hello</span>))
    };

    <span class='macro'>assert</span><span class='macro'>!</span>(
        <span class='ident'>hello_fn</span>()
    );
}

<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='string'>&quot;win64&quot;</span> <span class='kw'>fn</span> <span class='ident'>print</span>(<span class='ident'>buffer</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>, <span class='ident'>length</span>: <span class='ident'>u64</span>) <span class='op'>-&gt;</span> <span class='ident'>bool</span> {
    <span class='ident'>io</span>::<span class='ident'>stdout</span>().<span class='ident'>write_all</span>(<span class='kw'>unsafe</span> {
        <span class='ident'>slice</span>::<span class='ident'>from_raw_parts</span>(<span class='ident'>buffer</span>, <span class='ident'>length</span> <span class='kw'>as</span> <span class='ident'>usize</span>)
    }).<span class='ident'>is_ok</span>()
}</pre>

<p>As you can see, the encoding has been determined fully at compile time, and the assembly has been reduced to a series of push and extend calls.</p>

<h1 id='advanced-usage' class='section-header'><a href='#advanced-usage'>Advanced usage</a></h1>
<p>Coming soon.</p>

    <script type="text/javascript">
        window.playgroundUrl = "";
    </script>
    </section>

</body>
</html>